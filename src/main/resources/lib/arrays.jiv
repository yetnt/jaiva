scope("strict")! @ This freezes all the functions, and elevates all warnings to fatal crashes.

{
    Code here, as written in Jaiva itself unlike other Jaiva libraries being written in Java,
    will constantly be updated and improved as syntax evolves and new features are added to the language.
    An example : Moving away from constant flat() calls to using v5 spread syntax for arrays, which is more concise
    readable, efficient, and easier to use. Also a very functional way of working with arrays.
    Another example : JDoc "example" tags being used to provide clear examples of how to use each function.
}

@* Remove n elements from the end of an array
@* p        $> arr <- [] The original array
@* p        $> n <- number Amount of elements to remove
@* returns  $> An array which contains the original array with n amount of elements removed from the end.
@* since     $> 1.0.0-beta.3
@* devn     $> Throws if the first argument is not an array or if the second argument is not a non-negative number.
@*          $> Not to be confused with a_delete() which removes elements from a specific index in an array.
@* example  $> maak arr <-| 1, 2, 3, 4, 5!
@*          $> khuluma(a_remove(arr, 2))! @ Returns [1, 2, 3]
@*          $> khuluma(a_remove(arr, 0))! @ Returns [1, 2, 3, 4, 5]
@*          $> khuluma(a_remove(arr, 5))! @ Returns []
kwenza *a_remove(arr, n) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_remove() only works on arrays"!
    <~ mara if (typeOf(n) != "number" || n < 0) ->
        cima <== "a_remove()'s second argument must be a non-negative number"!
    <~
    maak returnValue <-|!
    colonize i <- 0 | i < arr~ - n | + ->
        @ Pre v5 code
@         returnValue <- flat(returnValue, arrLit(arr[i]))!
        returnValue <- arrLit(returnValue:::, arr[i])!
    <~
    khutla returnValue!
<~


@* Pops the last element off an array and returns a new array without that element.
@* p        $> array <- [] The original array
@* devn     $> This is just a wrapper for the _a_remove()_ function, it doesn't matter which one you use
@*          $> Throws if the argument is not an array.
@* deps     $> a_remove
@* returns  $> A new array without the last element of the original array.
@* since     $> 1.0.0-beta.3
@* example  $> maak arr <-| 1, 2, 3, 4, 5!
@*          $> khuluma(a_pop(arr))! @ Returns [1, 2, 3, 4]
kwenza *a_pop(array) ->
    if (typeOf(array) != "array") ->
        cima <== "a_pop() only works on arrays"!
    <~
    khutla a_remove(array, 1)!
<~


@* Appends an element to the end of an array and returns the new array.
@* p        $> arr <- [] The original array
@* p        $> element <- any Element to add
@* returns  $> A new array with the element appended at the end of the array.
@* since     $> 1.0.0-beta.3
@* devn     $> Throws if the first argument is not an array.
@* example  $> maak arr <-| 1, 2, 3!
@*          $> khuluma(a_push(arr, 4))! @ Returns [1, 2, 3, 4]
kwenza *a_push(arr, element) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_push() only works on arrays"!
    <~
    @ Pre v5
@     khutla flat(arr, arrLit(element))!
    khutla arrLit(arr:::, element)!
<~

@* Appends multiple elements to the end of an array and returns the new array.
@* p        $> params <- idk A variable number of arguments where the first argument is the original array
@*          $> and the rest are the elements to add
@* returns  $> A new array with the elements appended at the end of the array.
@* since     $> 5.0.0
@* devn     $> Throws if the first argument is not an array.
@* example  $> maak arr <-| 1, 2, 3!
@*          $> khuluma(a_pushAll(arr, 4, 5, 6))! @ Returns [1, 2, 3, 4, 5, 6]
kwenza *a_pushAll(<-params) ->
    maak arr <- params[0]!
    if (typeOf(arr) != "array") ->
        cima <== "a_pushAll() only works on arrays"!
    <~
    maak returnArr <- arr!
    colonize i <- 1 | i < params~ | + ->
        returnArr <- arrLit(returnArr:::, params[i])!
    <~
    khutla returnArr!
<~


@* Appends an element to the start of an array and returns the new array.
@* p        $> arr <- [] The original array
@* p        $> element <- any Element to add
@* returns  $> A new array with the element appended at the start of the array.
@* since    $> 1.0.0-beta.3
@* devn     $> Throws if the first argument is not an array.
@* example  $> maak arr <-| 2, 3, 4!
@*          $> khuluma(a_unshift(arr, 1))! @ Returns [1, 2, 3, 4]
kwenza *a_unshift(arr, element) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_unshift() only works on arrays"!
    <~
@     khutla flat(arrLit(element), arr)!
    khutla arrLit(element, arr:::)!
<~


@* Removes n elements from the start of an array
@* p        $> arr <- [] The original array
@* p        $> n <- number Amount of elements to remove
@* returns  $> An array which contains the original array with n amount of elements removed from the start.
@* devn     $> This uses a colonize loop to iterate through the array and skip the first n elements.
@*          $> It may not be the most efficient way to do this, but it works.
@*          $> Throws if the first argument is not an array or if the second argument is not a non-negative number.
@* since    $> 1.0.0-beta.3
@* example  $> maak arr <-| 1, 2, 3, 4, 5!
@*          $> khuluma(a_shift(arr, 2))! @ Returns [3, 4, 5]
@*          $> khuluma(a_shift(arr, 0))! @ Returns [1, 2, 3, 4, 5]
@*          $> khuluma(a_shift(arr, 5))! @ Returns []
kwenza *a_shift(arr, n) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_shift() only works on arrays"!
    <~ mara if (typeOf(n) != "number" || n < 0) ->
        cima <== "a_shift()'s second argument must be a non-negative number"!
    <~
    maak returnValue <-|!
    colonize i <- 0 | i < arr~ | + ->
        if (n > i) ->
            nevermind!
        <~
@         returnValue <- flat(returnValue, arrLit(arr[i]))!
        returnValue <- arrLit(returnValue:::, arr[i])!
    <~
    khutla returnValue!
<~


@* Filter an array based on a predicate function
@* p        $> arr <- [] The original array
@* p        $> predicate <- F~any A function that takes an element and returns true
@* returns  $> A new array with elements that satisfy the predicate function.
@* devn     $> The predicate function must take in 1 parameter, the element and return a boolean.
@*          $> Throws if the first argument is not an array or if the second argument is not a function.
@* since    $> 1.0.0-beta.3
@* example  $> maak arr <-| 1, 2, 3, 4, 5, 6!
@*          $> maak isEven <- f~(num) : num % 2 = 0! @ A lambda function to check if a number is even
@*          $> khuluma(a_filter(arr, isEven))! @ Returns [2, 4, 6]
kwenza *a_filter(arr, F~predicate) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_filter() only works on arrays"!
    <~ mara if (typeOf(predicate) != "function") ->
        cima <== "a_filter()'s second argument must be a function"!
    <~
    maak empty <-|!
    colonize element with arr ->
        if (predicate(element) = true) ->
@             empty <- flat(empty, arrLit(element))!
        empty <- arrLit(empty:::, element)!
        <~
    <~

    khutla empty!
<~

@* Replace an element at a specific index in an array with a new element
@* p        $> arr <- [] The original array
@* p        $> i <- number The index to replace
@* p        $> el <- any The new element to insert
@* returns  $> A new array with the element at index i replaced with el
@* devn     $> Throws if the first argument is not an array or if the index is out of bounds.
@* since    $> 3.0.0
@* example  $> maak arr <-| 1, 2, 3, 4, 5!
@*          $> khuluma(a_replace(arr, 2, 99))! @ Returns [1, 2, 99, 4, 5]
kwenza *a_replace(arr, i, el) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_replace() only works on arrays"!
    <~ mara if (typeOf(i) != "number" || i < 0 || i >= arr~) ->
        @ The following constructs a string that explains why the index is invalid
        @ (e.g., "i < 0", "i >= arr~", or "i != number")
        maak str <- (typeOf(i) = "number" => ( i >= arr~ => "i >= arr~" however "i < 0" ) however "i != number")!
        cima <== "a_replace()'s second argument must be a valid index " + str!
    <~
    maak newArr <-|!
    colonize index <- 0 | index < arr~ | + ->
        if (index = i) ->
@             newArr <- flat(newArr, arrLit(el))!
            newArr <- arrLit(newArr:::, el)!
        <~ mara ->
@             newArr <- flat(newArr, arrLit(arr[index]))!
            newArr <- arrLit(newArr:::, arr[index])!
        <~
    <~
    khutla newArr!
<~

@* Deletes an element at a specific index in an array and shifts the rest of the elements to the left
@* p        $> arr <- [] The original array
@* p        $> i <- number The index to delete
@* returns  $> A new array with the element at index i removed and the
@*          $> rest of the elements shifted to the left
@* devn     $> Throws if the first argument is not an array or if the index is out of bounds.
@*          $> Not to be confused with a_remove() which removes elements from the end of an array
@* since    $> 3.0.0
@* example  $> maak arr <-| 1, 2, 3, 4, 5!
@*          $> khuluma(a_delete(arr, 2))! @ Returns [1, 2, 4, 5]
kwenza *a_delete(arr, i) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_delete() only works on arrays"!
    <~ mara if (typeOf(i) != "number" || i < 0 || i >= arr~) ->
        @ The following constructs a string that explains why the index is invalid
        @ (e.g., "i < 0", "i >= arr~", or "i != number")
        maak str <- (typeOf(i) = "number" => ( i >= arr~ => "i >= arr~" however "i < 0" ) however "i != number")!
        cima <== "a_delete()'s second argument must be a valid index " + str!
    <~
    maak newArr <-|!
    colonize index <- 0 | index < arr~ | + ->
        if (index = i) ->
            nevermind!
        <~ mara ->
@             newArr <- flat(newArr, arrLit(arr[index]))!
            newArr <- arrLit(newArr:::, arr[index])!
        <~
    <~
    khutla newArr!
<~

@* Finds the first occurrence of an element in an array and returns its index
@* p        $> arr <- [] The original array
@* p        $> el <- any The element to find
@* returns  $> The index of the first occurrence of el in arr, or idk if not found
@* devn     $> This uses the search first approach, it may not be the most efficient way to do this, but it works.
@*          $> Throws if the input is not an array.
@* since    $> 3.0.0
@* example  $> maak arr <-| "apple", "banana", "cherry", "date", "banana"!
@*          $> khuluma(a_indexOf(arr, "banana"))! @ Returns 1
@*          $> khuluma(a_indexOf(arr, "date"))! @ Returns 3
@*          $> khuluma(a_indexOf(arr, "fig"))! @ Returns idk
kwenza *a_indexOf(arr, el) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_indexOf() only works on arrays"!
    <~
    colonize index <- 0 | index < arr~ | + ->
        if (arr[index] = el) ->
            khutla index!
        <~
    <~
    khutla idk!
<~

@* Reverses the order of elements in an array and returns a new array
@* p        $> arr <- [] The original array
@* returns  $> A new array with the elements in reverse order
@* devn     $> This uses a colonize loop to iterate through the array backwards
@*          $> and constructs a new array with the elements in reverse order.
@*          $> Throws if the input is not an array.
@* since    $> 3.0.0
@* example  $> maak arr <-| 1, 2, 3, 4, 5!
@*          $> khuluma(a_reverse(arr))! @ Returns [5, 4, 3, 2, 1]
kwenza *a_reverse(arr) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_reverse() only works on arrays"!
    <~
    maak newArr <-|!
    colonize i <- arr~ - 1 | i >= 0 | - ->
@         newArr <- flat(newArr, arrLit(arr[i]))!
        newArr <- arrLit(newArr:::, arr[i])!
    <~
    khutla newArr!
<~

@* Reduces an array to a single value using a reducer function
@* p        $> arr <- [] The original array
@* p        $> reducer <- F~any A function that takes an accumulator and an
@*          $> element and returns a new accumulator
@* p        $> initial? <- any An optional initial value for the accumulator
@* returns  $> The final value of the accumulator after processing all elements
@* devn     $> The reducer function must take in 2 parameters, the accumulator
@*          $> and the current element, and return the new value of the accumulator.
@*          $> If no initial value is provided, the first element of the array
@*          $> is used as the initial value and the reduction starts from the second element
@*          $> Throws if the first argument is not an array or if the second argument is not a function.
@* since    $> 3.0.0
@* example  $> maak arr <-| 1, 2, 3, 4!
@*          $> maak sumReducer <- f~(acc, el) : acc + el! @ A lambda function to sum two numbers
@*          $> khuluma(a_reduce(arr, sumReducer, 0))! @ Returns 10
@*          $> khuluma(a_reduce(arr, sumReducer))! @ Returns 10
kwenza *a_reduce(arr, F~reducer, initial?) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_reduce() only works on arrays"!
    <~ mara if (typeOf(reducer) != "function") ->
        cima <== "a_reduce()'s second argument must be a function"!
    <~
    maak accumulator <- initial!
    colonize element with arr ->
        if (accumulator = idk) ->
            accumulator <- element!
            nevermind!
        <~ mara ->
            accumulator <- reducer(accumulator, element)!
        <~
    <~
    khutla accumulator!
<~

@* Transforms every element in an array using a provided function.
@* p        $> arr <- [] The original array to map over.
@* p        $> mapperFunction <- F~any A function that takes one element and returns its transformed value.
@* returns  $> A new array populated with the results of calling the mapperFunction on every element.
@* since    $> 4.1.1
@* devn     $> The mapperFunction must take in 1 parameter (the element).
@*          $> Throws if the first argument is not an array or if the second argument is not a function.
@* example  $> maak arr <-| 1, 2, 3, 4!
@*          $> maak square <- f~(num) : num * num! @ A lambda function to square a number
@*          $> khuluma(a_map(arr, square))! @ Returns [1, 4, 9, 16]
kwenza *a_map(arr, F~mapperFunction) ->
    if (typeOf(arr) != "array") ->
        cima <== "a_reduce() only works on arrays"!
    <~ mara if (typeOf(mapperFunction) != "function") ->
        cima <== "a_reduce()'s second argument must be a function"!
    <~
    maak new <-|!
    colonize el with arr ->
@         new <- flat(new, arrLit(mapperFunction(el)))!
        new <- arrLit(new:::, mapperFunction(el))!
    <~
    khutla new!
<~